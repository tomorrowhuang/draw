<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>隨機分組抽籤程式 (拉霸動畫版)</title>
    <style>
        body {
            font-family: 'Segoe UI', Microsoft JhengHei, sans-serif;
            background-color: #f0f4f8;
            margin: 0;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 左上角歷史紀錄區域 */
        #history-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: flex-start;
            z-index: 10;
        }

        .history-item {
            font-size: 1.5rem; 
            color: #555;
            background: #e0e0e0;
            padding: 5px 10px;
            border-radius: 5px;
        }

        /* 中間主要抽籤區域 */
        #main-stage {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #current-draw {
            display: flex;
            gap: 30px; /* 框框之間的距離 */
            min-height: 180px;
        }

        .draw-item {
            /* 主要顯示字體大小 */
            font-size: 4rem; 
            font-weight: bold;
            color: #2c3e50;
            background: #fff;
            
            /* 固定寬高，讓動畫跑起來更穩定 */
            width: 180px;
            height: 180px;
            display: flex;
            justify-content: center;
            align-items: center;

            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            border: 4px solid #3498db; /* 加粗邊框更有框框感 */
            
            /* 預設狀態 */
            transition: border-color 0.3s, transform 0.2s;
        }
        
        /* 動畫進行中的樣式 (可選) */
        .draw-item.rolling {
            border-color: #f1c40f; /* 轉動時邊框變黃色 */
            color: #95a5a6;
        }

        /* 結果出爐時的彈出動畫 */
        .pop-finish {
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border-color: #e74c3c; /* 確定後邊框變紅色 */
            color: #2c3e50;
        }

        /* 按鈕區域 */
        #controls {
            margin-bottom: 50px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        button {
            font-size: 1.2rem;
            padding: 15px 40px;
            cursor: pointer;
            border: none;
            border-radius: 50px;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* 按鈕停用狀態 (動畫中) */
        button:disabled {
            background-color: #bdc3c7 !important;
            color: #7f8c8d !important;
            cursor: not-allowed;
            transform: scale(0.98);
        }

        #drawBtn {
            background-color: #3498db;
            color: white;
        }
        #drawBtn:hover { background-color: #2980b9; }
        
        #resetBtn {
            background-color: #95a5a6;
            color: white;
            font-size: 1rem;
            padding: 10px 20px;
        }
        #resetBtn:hover { background-color: #7f8c8d; }

        @keyframes popIn {
            from { transform: scale(0.8); }
            to { transform: scale(1.1); }
        }
    </style>
</head>
<body>

    <div id="history-container"></div>

    <div id="main-stage">
        <div id="current-draw"></div>
    </div>

    <div id="controls">
        <button id="drawBtn" onclick="startDrawAnimation()">開始抽籤</button>
        <div id="status" style="color: #777;">載入中...</div>
        <button id="resetBtn" onclick="hardReset()" style="display:none;">清除紀錄並重置</button>
    </div>

    <script>
        // 設定常數
        const STORAGE_KEY = 'lottery_draw_data_v3_anim'; // 更改 key 以免跟舊版衝突
        const itemsPerDraw = 3;
        const totalRounds = 8;

        // 全域變數
        let allItems = [];
        let currentIndex = 0;
        let isAnimating = false; // 用來鎖定按鈕

        window.onload = function() {
            loadState();
        };

        // 1. 讀取狀態
        function loadState() {
            const savedData = localStorage.getItem(STORAGE_KEY);
            if (savedData) {
                const parsed = JSON.parse(savedData);
                allItems = parsed.allItems;
                currentIndex = parsed.currentIndex;
                restoreUI(false); // false 代表不要執行動畫，直接顯示結果
            } else {
                initNewGame();
            }
            updateStatus();
        }

        // 2. 初始化新局
        function initNewGame() {
            const groupB = Array.from({length: 12}, (_, i) => `B${i+1}`);
            const groupS = Array.from({length: 12}, (_, i) => `S${i+1}`);
            allItems = [...groupB, ...groupS];
            // 洗牌
            for (let i = allItems.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
            }
            currentIndex = 0;
            saveState();
            restoreUI(false);
        }

        // 3. 儲存狀態
        function saveState() {
            const state = { allItems, currentIndex };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            updateStatus();
        }

        // 4. 恢復畫面 UI (mode: 'final' 直接顯示最終結果, 'empty' 顯示動畫前的空框)
        function restoreUI(showAnimationPlaceholders) {
            const historyContainer = document.getElementById('history-container');
            const currentDrawContainer = document.getElementById('current-draw');
            
            // 清空目前的顯示
            historyContainer.innerHTML = '';
            
            // A. 處理歷史區 (邏輯不變)
            const historyEndIndex = Math.max(0, currentIndex - itemsPerDraw);
            // 注意：如果是正在執行動畫的當下，currentIndex 已經加了，但我們希望上一輪的還在歷史區
            // 不過為了簡單邏輯，我們讓歷史區總是顯示 "這次抽籤之前" 的所有項目
            
            for (let i = 0; i < historyEndIndex; i++) {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.textContent = allItems[i];
                historyContainer.appendChild(div);
            }

            // B. 處理中間區
            // 如果不是在跑動畫，就直接顯示目前的結果
            if (!showAnimationPlaceholders) {
                currentDrawContainer.innerHTML = ''; // 清空
                if (currentIndex > 0) {
                    for (let i = historyEndIndex; i < currentIndex; i++) {
                        const div = document.createElement('div');
                        div.className = 'draw-item'; // 普通樣式
                        div.textContent = allItems[i];
                        currentDrawContainer.appendChild(div);
                    }
                }
            }
        }

        // 5. 核心：開始抽籤動畫
        function startDrawAnimation() {
            if (isAnimating) return; // 防止連點

            // 檢查結束
            if (currentIndex >= allItems.length) {
                if(confirm("所有組別已抽出。確定要清除紀錄並開始新的一局嗎？")) {
                    hardReset();
                }
                return;
            }

            isAnimating = true;
            const drawBtn = document.getElementById('drawBtn');
            drawBtn.disabled = true; // 鎖定按鈕
            drawBtn.textContent = "抽籤中...";

            // 1. 先把舊的移到歷史區 (透過 restoreUI 重新渲染歷史區)
            // 此時 currentIndex 還沒加，所以歷史區是舊的，中間區我們手動清空準備做動畫
            const historyContainer = document.getElementById('history-container');
            const currentDrawContainer = document.getElementById('current-draw');
            
            // 將目前畫面上的東西移入歷史區 (視覺上) - 簡單作法是直接把 currentIndex 更新並重繪歷史
            // 但我們需要中間這 3 個框框變成「動畫狀態」
            
            // 決定這次要抽出的 3 個幸運號碼
            const finalResults = allItems.slice(currentIndex, currentIndex + itemsPerDraw);
            
            // 準備 DOM：清空中間，建立 3 個正在轉動的框
            currentDrawContainer.innerHTML = '';
            const slotElements = []; // 存這3個div參照

            for(let i=0; i<3; i++) {
                const div = document.createElement('div');
                div.className = 'draw-item rolling'; // 加上轉動樣式
                div.textContent = getRandomPlaceholder(); // 初始隨機文字
                currentDrawContainer.appendChild(div);
                slotElements.push(div);
            }

            // 2. 開始個別的動畫邏輯
            let completedCount = 0;

            finalResults.forEach((targetValue, index) => {
                // 每個框框的動畫時間：隨機 2000ms ~ 4000ms
                const duration = 2000 + Math.random() * 2000;
                
                // 啟動快速跳字 (每 50ms 換一次)
                const intervalId = setInterval(() => {
                    slotElements[index].textContent = getRandomPlaceholder();
                }, 50);

                // 設定停止時間
                setTimeout(() => {
                    clearInterval(intervalId); // 停止跳動
                    slotElements[index].textContent = targetValue; // 顯示正確答案
                    slotElements[index].classList.remove('rolling'); // 移除轉動樣式
                    slotElements[index].classList.add('pop-finish'); // 加上完成特效
                    
                    completedCount++;
                    
                    // 當 3 個都停下來時，才解除鎖定並存檔
                    if (completedCount === 3) {
                        finishRound();
                    }
                }, duration);
            });
        }

        // 6. 動畫結束後的收尾工作
        function finishRound() {
            currentIndex += itemsPerDraw; // 正式推進進度
            saveState(); // 存檔
            isAnimating = false;
            
            // 更新歷史區顯示 (把剛剛中間的「舊」資料補進去，但中間保留剛剛動畫完的結果)
            // 這裡我們只更新歷史區，不動中間區(因為中間區剛動畫完，還熱騰騰的)
            const historyContainer = document.getElementById('history-container');
            historyContainer.innerHTML = '';
            const historyEndIndex = currentIndex - itemsPerDraw;
            for (let i = 0; i < historyEndIndex; i++) {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.textContent = allItems[i];
                historyContainer.appendChild(div);
            }

            updateStatus(); // 解鎖按鈕
        }

        // 輔助：產生隨機的假文字 (B1..S12) 讓動畫看起來像真的在挑
        function getRandomPlaceholder() {
            const prefix = Math.random() > 0.5 ? 'B' : 'S';
            const num = Math.floor(Math.random() * 12) + 1;
            return `${prefix}${num}`;
        }

        function updateStatus() {
            const drawBtn = document.getElementById('drawBtn');
            const statusLabel = document.getElementById('status');
            const resetBtn = document.getElementById('resetBtn');

            const roundsLeft = totalRounds - (currentIndex / itemsPerDraw);

            if (currentIndex > 0 && roundsLeft > 0) {
                resetBtn.style.display = 'block';
            } else {
                resetBtn.style.display = 'none';
            }

            // 如果正在動畫中，不要改按鈕文字 (保持 "抽籤中...")
            if (isAnimating) return;

            drawBtn.disabled = false;

            if (currentIndex === 0) {
                drawBtn.textContent = "開始抽籤";
                drawBtn.style.backgroundColor = "#3498db";
                statusLabel.textContent = `剩餘次數: ${totalRounds}`;
            } else if (roundsLeft === 0) {
                drawBtn.textContent = "抽籤結束 (點擊開始新局)";
                drawBtn.style.backgroundColor = "#27ae60";
                statusLabel.textContent = "已完成所有分組";
                resetBtn.style.display = 'none'; 
            } else {
                drawBtn.textContent = "抽取下一組";
                drawBtn.style.backgroundColor = "#3498db";
                statusLabel.textContent = `剩餘次數: ${roundsLeft}`;
            }
        }

        function hardReset() {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }
    </script>
</body>
</html>
